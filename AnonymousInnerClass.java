
public interface Employee{
    String getName();
    String getDesignation();
}

// Traditional way of implementing the interface Employee

// class MyClass implements Employee{
//     @Override
//     public String getName(){
//         return "Ram";
//     }

//     @Override
//     public String getDesignation(){
//         return "Software Engineer";
//     }
// }

public class AnonymousInnerClass {
    public static void main(String[] args) {
        
        // MyClass myClassRef = new MyClass();
        // System.out.println(myClassRef.getName());
        // System.out.println(myClassRef.getDesignation());


        // The above code is pure traditional way 

        // But now we don't have to write a seperate implementation class for it we can directly write the implementation of those interface methods

        Employee employeeRef = new Employee() {
            
            @Override
            public String getName(){
                return "Ram";
            }

            @Override
            public String getDesignation(){
                return "Software Engineer";
            }

        };

        System.out.println(employeeRef.getName(), employeeRef.getDesignation());



        // So here behind the scene is something like (i.e. When we write an Anonymous inner class then the compiler will automatically generates a class that implements this interface that we don't see basically and that memory location of that class will get stored inside the "employeeRef" reference variable.)

        // Now we may ask that why the Reference Type is Employee because it is an interface. Here we need to write the Reference Type of that class that implements that interface right! 

        // --> Basically since the class is auto generated by the compiler and we don't see it i.e. What is the name of that class as a result we use the Reference Type as Employee (i.e. The name of the interface) such that we can use those methods that is the part of the Employee interface.


    }
}
